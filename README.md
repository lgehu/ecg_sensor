# ECG SENSOR #
The goal is to virtualize a sensor in the STM32F446RE that can process ECG data to detect heart rate with the Pan-Tompkins algorithm.
Data are transmit through UART with a python script, then, the MCU process the data in real time and should return the heart rate.

## SCRIPTS ## 
- uart_test.py: Is intented for testing the UART and transmist signed integer on 16 bits.  
- filters_proto.py: Is for testing algorithm of filter to be implemented on Ada.  
- read_ecg_sensor.py: Read an ECG signal from the board and display it 
- ecg_uart_test.py: Is for sending a whole ECG signal. 
to_ada.py: Is for converting any file to an ada array
## PREREQUISITES (Linux) ##
You will need Alire, st-flash, python3 and the right toolchain for Ada (gnat-arm-elf).  
Download the package manager for Ada (Alire):  
```bash
wget https://github.com/alire-project/alire/releases/download/v2.0.2/alr-2.0.2-bin-x86_64-linux.zip
unzip alr-2.0.2-bin-x86_64-linux.zip
mv alr-2.0.2-bin-x86_64-linux/bin /usr/bin/alr`
alr toolchain --select gnat_arm_elf=14.2.1 gprbuild=22.0.1
```
Then, download the ADL fork for Alire beside this project:   
```bash
git clone https://github.com/lgehu/alr_adl_crates.git
```
Your_folder   
│  
├── ecg_sensor  
├── alr_adl_crates  
    
## COMPILATION ##
Plug your device to your computer, then to compile the Ada project run:   
`make PRJ_NAME=ecg_test`
You can replace 'ecg_test' with an other file in the src/test folder.  
You should change in the makefile the port of your device if needed.

## Flashing an ECG file to the board ## 

### Testing with object linker 

Create an object file to be linked to the program.
```bash
alr exec -- arm-eabi-objcopy -I binary -O elf32-littlearm -B arm --rename-section .data=.rodata test.txt obj/test.o
```
Or,
```bash 
alr exec -- ld -r -b binary --section-start=.rodata=0x0807F000 -o obj/test.o test.txt
```

To show the generated symboles names, we can print them with:
```bash
alr exec -- arm-eabi-nm obj/test.o
```

To print the content of the file:
```bash
alr exec -- arm-eabi-objdump -s -j .rodata obj/test.o
```

In the GPR add the following lines:
```Ada
package Linker is
      for Linker_Options use ("obj/test.o");
end Linker;

```
In Ada, we can then load the symboles:
```Ada
   Fichier_Start : System.Address;
   pragma Import (C, Fichier_Start, "_binary_test_txt_start");
   Fichier_End : System.Address;
   pragma Import (C, Fichier_End, "_binary_test_txt_end");
```
This doesn't work. First, the only way we found to link an object the binary is by adding an argument to command line ( -largs obj/test.o). Linker options added in the GPR didn't work.
Once the exernal file linked, the addresses Text_Start and Text_End in the Ada program were not acceptable. For example we had sometime negative value, or Text_Start higher than Text_End. The issue could be during the "ld", dealing bad with these external symbols.

### Solution with a script
In the script folder, the file to_ada.py take an arbitrary file and generate an array of bytes in the Ada syntax. This way, we can embbed any data during the compilation.
The script can be used like this:
```bash 
python3 scripts/to_ada.py physionet.org/files/ptb-xl/1.0.3/records100/00000/00001_lr src/ecgdata.ads ECGData --wfdb
```
Execution of the script that allows to convert a .dat dataset into a Ada spec file [Package name]. For our example we used ECGData.
It will generate an array of float32. Then, in the `ecg_script_test.adb`, we iterate through the array, convert it to Int16 and send it using UART at a given sample rate.
`read_ecg_sensor.py` will acquire data and convert it back to float.

# Pan-Tompkins
We implemented the Pan-Tompkins algorithm on the STM32F446RE. According to the paper, it filter the input data with a pass-band from 5 Hz to 15 Hz. Currently, its a simple IIR filter, but we could enhance it by using the DSP  and CMSIS library to implement a butterworth in some future. Then, it square the signal and perform a moving window to smooth the signal. Finally, to detect the pick, it compute one threshold based on the average amplitude, and the second treshold is a minimal distance between picks.

## Demo
The ecg_test.adb program use an ECG signal generated by the to_ada.py script. Then, results of the processed signal is sent through UART and plotted to be compared with the Pan-Tompkins python version. 
On the following picture, the first one is an ECG signal processed by the python algorithm from this [repo](https://github.com/lgehu/Pan-Tompkins-algorithm-python.git).   
![python-algo](https://github.com/user-attachments/assets/b64c858f-ec68-40bc-9dfc-82cd7c9bac8a)  
The next one is the same ECG signal processed by the Ada implementation. We can see similar results: No false positive, same picks number and detected on the same time.
However, amplitude are different because lowpass and highpass are IIR functions instead of butterworth. Thus, gain response are not the same. 
![ada-algo](https://github.com/user-attachments/assets/8a5ad799-4a83-48e4-911f-79fcc074056d)  
## How to use
Here is the following script and command we used to get the precedent results.  
First, transform an ECG signal into an ada array: `python3 scripts/to_ada.py physionet.org/files/ptb-xl/1.0.3/records100/00000/00001_lr src/ecgdata.ads ECGData --wfdb`  
Next, compile the program and flash it: `make PRJ_NAME=ecg_test`  
If you only want the raw data outputted by the board, use: `make PRJ_NAME=ecg_script_test`  
It will send the raw signal casted to Int16 through UART.  
Then, execute the python script to display the result: `python3 scripts/read_ecg_sensor.py`  
You can restart the board, it will send the data in a singleshot.  

# TODO #
- [V] Implement the Pan-Tompkins algorithm
- [V] Python script to flash an ECG signal directly in the board. 
- [] Enhance the algorithm using the DSP and CMSIS Library

# ISSUES #
Python package wfdb and matplotlib wasn't working fine on linux. I had to create a
pyenv:   
`python3 -m venv`   
`source ecg_sensor/bin/activate`
Then,   
`pip install wfdb matplotlib pystruct pyserial`
